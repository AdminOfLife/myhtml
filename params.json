{"name":"Myhtml","tagline":"MyHTML — HTML Parser on Pure C with POSIX Threads Support","body":"Hi, there!  \r\n\r\nAs you might have guessed from the title, today's topic is HTML parsing.\r\n\r\n###   Preface  \r\n\r\nOnce I got an X idea, but its implementation required a calculated DOM with all its styles and goodies. Googling retrieved nothing useful. There are all kinds of bindings for WebKit, but they work not on all platforms, being very crippled to boot. In some projects, WebKit is wrapped in a frontend you work with via JavaScript. Something was tried out — with a poor outcome though. Resource consumption alone required a lot.\r\n\r\n\r\n### Wants and Wishes\r\n\r\nWhat was wanted didn't seemed much: \r\n\r\n- HTML renderer without super dependencies. Only a renderer, without the network layer. In other words, complete HTML computation till drawing in a window\r\n- Ability to fit the envelop to a JavaScript engine\r\n- Ability to easily make bindings for other programming languages\r\n\r\n\r\n### And so I joined the unequal battle!\r\n\r\nI studied existing HTML and CSS parsers. They all fell into 3 conventional categories: \r\n\r\n- Those parsing at random, with their own approach to HTML tokenization\r\n- Those parsing somehow under specs\r\n- Those parsing strictly under specs\r\n\r\nGiven No. 3, the subject seems to be dropped, doesn't it?! Nope, and here's why: all existing parsers are made on the principle 'Parse and Die'. It's when you give the program complete HTML, the program returns a result, but all subsequent manipulations except reading are impossible. This fact limits the operation of parsers. Remarkably, some push operating DOM off a level up. Here's the principle: we parse with a C parser and then — via bindings — try to work with DOM on, say, Python, which is a bit absurd.\r\n\r\nFurther on, nobody allowed for wedging into the thread (HTML meant here) during parsing. This is critical for fitting a JavaScript engine. It's a long story — I'd better show:\r\n\r\nHTML document fragment:\r\n```html\r\n<script>document.write(\"<div cl\");</script>ass=\"future\"></div>\r\n```\r\n\r\nOutcome of any browser with JS:\r\n```html\r\n<div class=\"future\"></div>\r\n```\r\n\r\nSo, a fully featured DIV element will come out. By the way, SCRIPT tag tokenization is a hell of an effort. I had to draw a graph\r\n\r\nAfter all that had been seen, the decision was to code from scratch on C. And requirements to code appeared at once: \r\n\r\n- C99 support\r\n- Capability to separate the HTML parser from the renderer, to be used standalone\r\n- No external dependencies\r\n\r\n Why so tough — on C?! The solution had to be embedded so as to enable relatively easy framing for an external programming language.  \r\n\r\nHere's what was managed to be drafted hit and miss: \r\n\r\n- HTML parser\r\n- CSS parser\r\n- Selectors\r\n- Renderer of 'inline', 'inline-block', 'block', 'table'...\r\n\r\nThe renderer may deserve a long description, as the short phrase 'Renderer of inline elements' conceals a lot: handling fonts under specs, calculating text size, computing 'vertical-align', building an auxiliary tree to draw text and a whole lot more.\r\n\r\nAs a result of 2–3 years of unhurried development, I started rewriting the draft copy into a production version. The first was — quite logically — the HTML parser. \r\n\r\nAs a result of 2–3 years of unhurried development, I started rewriting the draft copy into a production version. The first was — quite logically — the HTML parser.  \r\n\r\nNow it has the following capabilities: \r\n\r\n- Parsing HTML asynchronously, processing tokens, building the tree\r\n- Full HTML 5 support under specs [html.spec.whatwg.org/multipage]\r\n- Having 2 APIs: [high] and [low]-level. The former is a public API having a description and everything it should, but unable to see structures. The latter is using sources directly\r\n- Ability to manipulate elements: addition, removal, modification\r\n- Ability to manipulate element attributes: addition, removal, modification\r\n- Support of 34 input encodings. Output and all internal work is in UTF-8 only\r\n- Ability to define text encoding Unicode now available: UTF-8, UTF-16LE, UTF-16BE (+ definition by BOM), and Russian ones: windows-1251, koi8-r, iso-8859-5, x-mac-Cyrillic, ibm866\r\n- Ability to run in single mode — without threads\r\n- Parsing HTML fragments\r\n- [Parsing chunks]. Parsing HTML cuts (broken in arbitrary places) without prebuffering\r\n- No external dependencies\r\n- C99 support\r\n- Passes all tree construction tests from [html5lib-tests]\r\n- Advanced memory management. Memory is cashed, allocated in chunks and for objects. For example, removing 10 elements and then adding other 10 won't eat away memory for the new ones\r\n\r\n+ a whole lot more small but useful features to be described for long.\r\n\r\nNext in turn are the CSS parser and Renderer. \r\nI'm writing them all by myself, still full of energy. \r\n\r\n Any help is very welcome!\r\n\r\nThanks for attention! Hope you'll enjoy it!\r\n\r\n[The parser itself] \r\n\r\n\r\n[html.spec.whatwg.org/multipage]: https://html.spec.whatwg.org/multipage/\r\n[high]: https://github.com/lexborisov/myhtml/blob/master/include/myhtml/api.h\r\n[low]: https://github.com/lexborisov/myhtml/tree/master/include/myhtml\r\n[Parsing chunks]: https://github.com/lexborisov/myhtml/blob/master/examples/chunks_high_level.c\r\n[html5lib-tests]: https://github.com/html5lib/html5lib-tests\r\n[The parser itself]: https://github.com/lexborisov/myhtml\r\n\r\n\r\n\r\n\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}